package generator

import (
	"encoding/json"
	"fmt"
	"log"
	"net/url"
	"os"
	"os/exec"
	"strings"
	"sync"

	"github.com/spf13/cobra"
	"github.com/taufik-rama/maiden/config.v1"
	"github.com/taufik-rama/maiden/internal"
	"github.com/taufik-rama/maiden/internal/writer"
)

// HTTP ...
type HTTP struct {
	Output     string
	ConfigHTTP config.ServiceHTTPList

	*sync.WaitGroup
}

// GenerateCommand is the handler for cobra command-line
func (h HTTP) GenerateCommand(*cobra.Command, []string) {

	for serviceName, detail := range h.ConfigHTTP {

		internal.Print("Generating HTTP services `%s`", serviceName)

		dir := h.Output + serviceName
		if err := os.MkdirAll(dir, os.ModePerm); err != nil {
			log.Fatalln(err)
		}

		filename := dir + string(os.PathSeparator) + serviceName + "-http.go"
		writer, err := writer.New(filename)
		if err != nil {
			log.Fatalln(err)
		}
		defer writer.Close()

		// Package & import
		writer.Write("// Code generated by maiden. DO NOT EDIT.")
		writer.WriteEmptyLine()
		writer.Write(`package main`)
		writer.WriteEmptyLine()
		writer.Write(`import "fmt"`)
		writer.Write(`import "net/http"`)
		writer.WriteEmptyLine()

		for api, values := range detail.Endpoints {
			writer.Write(`func %s(w http.ResponseWriter, r *http.Request) {`, toFuncName(api))
			writer.IncrIndentLevel()
			writer.WriteEmptyLine()

			writer.Write(`if r == nil { w.Write([]byte("{}")); return }`)
			writer.Write("fmt.Printf(\"Incoming request to `%s:%s`: %%s\\n\", r.URL)", serviceName, toFuncName(api))
			writer.WriteEmptyLine()

			writer.Write(`w.Header().Add("Content-Type", "application/json")`)

			for _, value := range values {

				if _, ok := value.Request.(string); !ok {
					continue
				}

				values, err := url.ParseQuery(value.Request.(string))
				if err != nil {
					log.Fatalf("Unable to parse the request as query: `%s/%s`", serviceName, api)
				}
				ifs := []string{}
				for key, values := range values {
					ifs = append(ifs, fmt.Sprintf(`r.URL.Query().Get("%s") == "%s"`, key, strings.Join(values, ",")))
				}

				if len(ifs) == 0 {
					writer.Write(`if true {`)
				} else {
					writer.Write(`if %s {`, strings.Join(ifs, " && "))
				}

				writer.IncrIndentLevel()
				writer.Write(`w.Write([]byte{`)

				writer.IncrIndentLevel()
				b, err := json.Marshal(value.Response)
				if err != nil {
					log.Fatalf("Unable to parse the response values: `%s:%s`", serviceName, api)
				}
				writeBytes(&writer, unescapeResponse(b))
				writer.DecrIndentLevel()

				writer.Write(`})`)
				writer.Write(`return`)
				writer.DecrIndentLevel()
				writer.Write(`}`)
			}

			writer.Write(`w.Write([]byte("{}"))`)
			writer.DecrIndentLevel()
			writer.Write(`}`)
			writer.WriteEmptyLine()
		}

		writer.Write(`func main() {`)
		writer.IncrIndentLevel()
		for api := range detail.Endpoints {

			// Special case: `/` path
			if strings.TrimSpace(api) == "" {
				writer.Write(`http.HandleFunc("/", %s)`, toFuncName(api))
			} else {
				writer.Write(`http.HandleFunc("%s", %s)`, prefixSlash(api), toFuncName(api))
			}
		}
		writer.Write((`fmt.Printf("` + "Starting `%s` on :%d" + `\n")`), serviceName, detail.Port)
		writer.Write(`panic(http.ListenAndServe(":%d", nil))`, detail.Port)
		writer.DecrIndentLevel()
		writer.Write("}")
		writer.WriteEmptyLine()
	}
}

func dashToUnderscore(url string) string {
	return strings.Join(strings.Split(url, "-"), "_")
}

func toFuncName(url string) string {
	url = eraseDot(url)
	ss := strings.Split(dashToUnderscore(url), "/")
	for i := range ss {
		if i == 0 {
			continue
		}
		ss[i] = strings.Title(ss[i])
	}

	name := strings.Join(ss, "")

	// Special case: `/` path
	if name == "" {
		name = "index"
	}

	return name
}

func prefixSlash(url string) string {
	if !strings.HasPrefix(url, "/") {
		return "/" + url
	}
	return url
}

func eraseDot(url string) string {
	return strings.Join(strings.Split(url, "."), "")
}

func writeBytes(writer *writer.Writer, bytes []byte) {

	row := -1
	result := [][]string{}
	for i := range bytes {
		if (i % 15) == 0 {
			row++
			result = append(result, []string{})
		}

		result[row] = append(result[row], fmt.Sprintf("%d", bytes[i]))
	}

	for _, res := range result {
		writer.Write(`%s,`, strings.Join(res, ","))
	}
}

func unescapeResponse(b []byte) []byte {
	b = []byte(strings.ReplaceAll(string(b), "\\\"", "\""))
	b = []byte(strings.Trim(string(b), "\""))
	return []byte(strings.ReplaceAll(string(b), "\\n", ""))
}

// RunCommand is the handler for cobra command-line
func (h HTTP) RunCommand(*cobra.Command, []string) {

	for name := range h.ConfigHTTP {
		internal.Print("Building `%s` service", name)
		if err := h.buildHTTP(h.Output, name); err != nil {
			log.Fatalln(err)
		}
	}

	for name := range h.ConfigHTTP {
		h.WaitGroup.Add(1)
		internal.Print("Starting `%s` service", name)
		go h.startHTTP(h.Output, name, h.WaitGroup)
	}
}

func (h HTTP) buildHTTP(output, name string) error {

	dir := output + name

	// I'm not using `go run` because that counts as 2 separate process
	if err := exec.Command("go", "build", "-o", (dir + string(os.PathSeparator) + name), (dir + string(os.PathSeparator) + name + "-http.go")).Run(); err != nil {
		return fmt.Errorf("error while building service `%s`, stderr: %s", name, err)
	}

	return nil
}

func (h HTTP) startHTTP(output, name string, waitGroup *sync.WaitGroup) {

	defer waitGroup.Done()

	dir := output + name
	command := exec.Command("./" + (dir + string(os.PathSeparator) + name))

	stderr := strings.Builder{}
	command.Stderr = &stderr
	command.Stdout = os.Stdout
	if err := command.Start(); err != nil {
		log.Printf("error while starting service `%s`, stderr: %s", name, stderr.String())
		return
	}

	command.Wait()

	if !command.ProcessState.Success() {
		log.Printf("error while listening `%s`, stderr: %s", name, stderr.String())
	}
}
